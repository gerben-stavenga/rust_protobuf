// protocrap-codegen/src/generator.rs

use crate::codegen::names::*;
use crate::codegen::static_gen;
use crate::codegen::tables;
use anyhow::Result;
use proc_macro2::TokenStream;
use prost_reflect::DescriptorPool;
use prost_reflect::DynamicMessage;
use quote::{format_ident, quote};
use super::protocrap;
use protocrap::reflection::is_repeated;
use protocrap::reflection::needs_has_bit;
use protocrap::google::protobuf::FileDescriptorSet::ProtoType as FileDescriptorSet;
use protocrap::google::protobuf::FileDescriptorProto::ProtoType as FileDescriptorProto;
use protocrap::google::protobuf::DescriptorProto::ProtoType as DescriptorProto;
use protocrap::google::protobuf::FieldDescriptorProto::Type;
use protocrap::google::protobuf::EnumDescriptorProto::ProtoType as EnumDescriptorProto;

pub fn generate_file_set(file_set: &FileDescriptorSet) -> Result<TokenStream> {
    let mut items = Vec::new();

    for file in file_set.file() {
        items.push(generate_file(file)?);
    }

    Ok(quote! {
        // Auto-generated by protocrap-codegen
        // DO NOT EDIT

        #(#items)*
    })
}

fn generate_file(file: &FileDescriptorProto) -> Result<TokenStream> {
    let mut items = Vec::new();

    // Generate enums
    for enum_type in file.enum_type() {
        items.push(generate_enum(enum_type)?);
    }

    // Generate messages
    for (idx, message) in file.message_type().iter().enumerate() {
        let mut path = Vec::new();
        path.push(idx);
        items.push(generate_message(message, file, path)?);
    }

    let file_descriptor = {
        use protocrap::ProtobufExt;
        let mut buffer = vec![0; 100000];
        let encoded = file.encode_flat::<100>(&mut buffer)?;

        // Get the descriptor from global pool
        let pool = DescriptorPool::global();
        let descriptor = pool
            .get_message_by_name("google.protobuf.FileDescriptorProto")
            .ok_or(anyhow::anyhow!(
                "FileDescriptorProto not found in global pool"
            ))?;

        // Decode as DynamicMessage
        let dynamic = DynamicMessage::decode(descriptor.clone(), encoded)?;

        // Generate static initializer
        static_gen::generate_static_dynamic(&dynamic)?
    };
    items.push(quote! {
        pub static FILE_DESCRIPTOR_PROTO: protocrap::google::protobuf::FileDescriptorProto::ProtoType = #file_descriptor;
    });
    let mut res = quote! { #(#items)* };
    for namespace in file.package().split('.').rev() {
        if namespace.is_empty() {
            continue;
        }
        let ident = format_ident!("{}", namespace);
        res = quote! {
        pub mod #ident {
            use super::protocrap;

            #res
        } };
    }
    Ok(res)
}

fn generate_enum(enum_desc: &&EnumDescriptorProto) -> Result<TokenStream> {
    let name = format_ident!("{}", enum_desc.name());

    // Enum variants
    let variants: Vec<_> = enum_desc
        .value()
        .iter()
        .map(|v| {
            let variant_name = format_ident!("{}", v.name());
            let number = v.number();
            quote! { #variant_name = #number }
        })
        .collect();

    // from_i32 match arms
    let from_i32_arms: Vec<_> = enum_desc
        .value()
        .iter()
        .map(|v| {
            let variant_name = format_ident!("{}", v.name());
            let number = v.number();
            quote! { #number => Some(Self::#variant_name) }
        })
        .collect();

    Ok(quote! {
        #[repr(i32)]
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        #[allow(non_camel_case_types)]
        pub enum #name {
            #(#variants,)*
        }

        impl #name {
            pub const fn from_i32(value: i32) -> Option<Self> {
                match value {
                    #(#from_i32_arms,)*
                    _ => None,
                }
            }

            pub const fn to_i32(self) -> i32 {
                self as i32
            }
        }
    })
}

fn generate_message(
    message: &DescriptorProto,
    file: &FileDescriptorProto,
    path: Vec<usize>,
) -> Result<TokenStream> {
    let msg = generate_message_impl(message, file, path)?;
    let name = format_ident!("{}", sanitize_field_name(message.name()));

    Ok(quote! {
        #[allow(non_snake_case)]
        pub mod #name {
            use super::protocrap;
            #[allow(unused_imports)]
            use protocrap::Protobuf;
            #msg
        }
    })
}

fn generate_message_impl(
    message: &DescriptorProto,
    file: &FileDescriptorProto,
    path: Vec<usize>,
) -> Result<TokenStream> {
    // Nested types first

    let mut nested_items = Vec::new();
    for (idx, nested) in message.nested_type().iter().enumerate() {
        let mut nested_path = path.clone();
        nested_path.push(idx);
        nested_items.push(generate_message(nested, file, nested_path)?);
    }

    let nested_enums: Vec<_> = message
        .enum_type()
        .iter()
        .map(generate_enum)
        .collect::<Result<Vec<_>, _>>()?;

    // Calculate has bits
    let has_bit_fields: Vec<_> = message.field().iter().filter(|f| needs_has_bit(f)).collect();

    let has_bits_count = has_bit_fields.len();
    let has_bits_words = (has_bits_count + 31) / 32;
    let has_bits_words = has_bits_words.max(1);

    // Struct fields
    let struct_fields: Vec<_> = message
        .field()
        .iter()
        .map(|&field| {
            let field_name = format_ident!("{}", sanitize_field_name(field.name()));
            let field_type = rust_field_type_tokens(field);
            (
                field_name.clone(),
                (field.number(), quote! { #field_name: #field_type }),
            )
        })
        .collect();

    let (struct_field_names, struct_fields): (Vec<_>, Vec<_>) = struct_fields.into_iter().unzip();
    let mut sorted_struct_fields: Vec<_> = struct_fields.clone();
    sorted_struct_fields.sort_by_key(|(field_num, _)| *field_num);

    let (_, struct_fields): (Vec<_>, Vec<_>) = struct_fields.into_iter().unzip();
    let (_, sorted_struct_fields): (Vec<_>, Vec<_>) = sorted_struct_fields.into_iter().unzip();

    // Build has_bit map
    let has_bit_map: std::collections::HashMap<_, _> = has_bit_fields
        .iter()
        .enumerate()
        .map(|(i, f)| (f.number(), i))
        .collect();

    // Accessor methods
    let accessors = generate_accessors(message, &has_bit_map)?;

    // Protobuf trait impl
    let protobuf_impl = generate_protobuf_impl();

    // Tables
    let encoding_table = tables::generate_encoding_table(message, &has_bit_map)?;
    let decoding_table = tables::generate_decoding_table(message, &has_bit_map)?;

    let file_descriptor_ident = format_ident!("FILE_DESCRIPTOR_PROTO");

    let package = file.package();
    let file_descriptor_path = if package.is_empty() {
        quote! { crate::#file_descriptor_ident }
    } else {
        let mut parts: Vec<_> = package.split('.').map(|s| format_ident!("{}", s)).collect();
        parts.push(file_descriptor_ident);

        quote! { crate::#(#parts)::* }
    };

    let message_descriptor_accessor = build_descriptor_accessor(&path);

    Ok(quote! {
        #(#nested_items)*
        #(#nested_enums)*

        #[repr(C)]
        #[derive(Debug, Default)]
        pub struct ProtoType {
            has_bits: [u32; #has_bits_words],
            #(#struct_fields,)*
        }

        impl ProtoType {
            pub const fn from_static(
                has_bits: [u32; #has_bits_words],
                #(#sorted_struct_fields,)*
            ) -> Self {
                Self {
                    has_bits,
                    #(#struct_field_names,)*
                }
            }

            pub const fn file_descriptor() -> &'static protocrap::google::protobuf::FileDescriptorProto::ProtoType {
                &#file_descriptor_path
            }

            const fn descriptor_proto() -> &'static protocrap::google::protobuf::DescriptorProto::ProtoType {
                #message_descriptor_accessor
            }

            #accessors
        }

        #protobuf_impl
        #encoding_table
        #decoding_table
    })
}

fn generate_accessors(
    message: &DescriptorProto,
    has_bit_map: &std::collections::HashMap<i32, usize>,
) -> Result<TokenStream> {
    let mut methods = Vec::new();

    for &field in message.field() {
        let field_name = format_ident!("{}", sanitize_field_name(field.name()));

        if is_repeated(field) {
            // Repeated field accessor
            if field.r#type() == Some(Type::TYPE_MESSAGE)
                || field.r#type() == Some(Type::TYPE_GROUP)
            {
                // Repeated message field
                let msg_type = rust_type_tokens(field);
                let field_name_mut = format_ident!("{}_mut", field_name);
                methods.push(quote! {
                    pub const fn #field_name(&self) -> &[&#msg_type::ProtoType] {
                        unsafe { core::mem::transmute(self.#field_name.slice()) }
                    }

                    pub fn #field_name_mut(&mut self) -> &mut protocrap::containers::RepeatedField<&mut #msg_type::ProtoType> {
                        unsafe { core::mem::transmute(&mut self.#field_name) }
                    }
                });
                continue;
            }
            let element_type = rust_element_type_tokens(field);
            let field_name_mut = format_ident!("{}_mut", field_name);
            methods.push(quote! {
                pub const fn #field_name(&self) -> &[#element_type] {
                    unsafe { core::mem::transmute(self.#field_name.slice()) }
                }

                pub fn #field_name_mut(&mut self) -> &mut protocrap::containers::RepeatedField<#element_type> {
                    &mut self.#field_name
                }
            });
        } else {
            match field.r#type().unwrap() {
                Type::TYPE_STRING => {
                    methods.push(quote! {
                        pub const fn #field_name(&self) -> &str {
                            self.#field_name.as_str()
                        }
                    });

                    if let Some(&has_bit) = has_bit_map.get(&field.number()) {
                        let setter_name = format_ident!("set_{}", field_name);
                        methods.push(quote! {
                            pub fn #setter_name(&mut self, value: &str, arena: &mut protocrap::arena::Arena) {
                                self.as_object_mut().set_has_bit(#has_bit as u32);
                                self.#field_name.assign(value, arena);
                            }
                        });
                    }
                }
                Type::TYPE_BYTES => {
                    methods.push(quote! {
                        pub const fn #field_name(&self) -> &[u8] {
                            self.#field_name.slice()
                        }
                    });

                    if let Some(&has_bit) = has_bit_map.get(&field.number()) {
                        let setter_name = format_ident!("set_{}", field_name);
                        methods.push(quote! {
                            pub fn #setter_name(&mut self, value: &[u8], arena: &mut protocrap::arena::Arena) {
                                self.as_object_mut().set_has_bit(#has_bit as u32);
                                self.#field_name.assign(value, arena);
                            }
                        });
                    }
                }
                Type::TYPE_MESSAGE | Type::TYPE_GROUP => {
                    let msg_type = rust_type_tokens(field);
                    methods.push(quote! {
                        pub const fn #field_name(&self) -> Option<&#msg_type::ProtoType> {
                            if self.#field_name.0.is_null() {
                                None
                            } else {
                                Some(unsafe { &*(self.#field_name.0 as *const #msg_type::ProtoType) })
                            }
                        }
                    });

                    let setter_name = format_ident!("{}_mut", field_name);
                    methods.push(quote! {
                        pub fn #setter_name(&mut self, arena: &mut protocrap::arena::Arena) -> &mut #msg_type::ProtoType {
                            let object = self.#field_name;
                            if object.0.is_null() {
                                let new_object = protocrap::base::Object::create(
                                    core::mem::size_of::<#msg_type::ProtoType>() as u32,
                                    arena
                                );
                                self.#field_name = protocrap::base::Message(new_object);
                            }
                            unsafe { &mut *(self.#field_name.0 as *mut #msg_type::ProtoType) }
                        }
                    });
                }
                Type::TYPE_ENUM => {
                    let enum_type = rust_type_tokens(field);
                    methods.push(quote! {
                        pub const fn #field_name(&self) -> Option<#enum_type> {
                            #enum_type::from_i32(self.#field_name)
                        }
                    });

                    if let Some(&has_bit) = has_bit_map.get(&field.number()) {
                        let setter_name = format_ident!("set_{}", field_name);
                        methods.push(quote! {
                            pub fn #setter_name(&mut self, value: #enum_type) {
                                self.as_object_mut().set_has_bit(#has_bit as u32);
                                self.#field_name = value.to_i32();
                            }
                        });
                    }
                }
                _ => {
                    // Scalar types
                    let return_type = rust_element_type_tokens(field);
                    methods.push(quote! {
                        pub const fn #field_name(&self) -> #return_type {
                            self.#field_name
                        }
                    });

                    if let Some(&has_bit) = has_bit_map.get(&field.number()) {
                        let setter_name = format_ident!("set_{}", field_name);
                        methods.push(quote! {
                            pub fn #setter_name(&mut self, value: #return_type) {
                                self.as_object_mut().set_has_bit(#has_bit as u32);
                                self.#field_name = value;
                            }
                        });
                    }
                }
            }
        }
    }

    Ok(quote! { #(#methods)* })
}

fn build_descriptor_accessor(path: &[usize]) -> TokenStream {
    if path.is_empty() {
        panic!("Message path cannot be empty");
    }

    let mut accessor = quote! { Self::file_descriptor() };

    for (level, &index) in path.iter().enumerate() {
        let index_lit = proc_macro2::Literal::usize_unsuffixed(index);

        if level == 0 {
            // First level: file's message_type array
            accessor = quote! {
                #accessor.message_type()[#index_lit]
            };
        } else {
            // Nested levels: nested_type array
            accessor = quote! {
                #accessor.nested_type()[#index_lit]
            };
        }
    }

    accessor
}

fn generate_protobuf_impl() -> TokenStream {
    quote! {
        impl protocrap::Protobuf for ProtoType {
            fn encoding_table() -> &'static [protocrap::encoding::TableEntry] {
                &ENCODING_TABLE.1
            }

            fn decoding_table() -> &'static protocrap::decoding::Table {
                &DECODING_TABLE.0
            }

        }
    }
}
