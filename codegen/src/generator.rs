// protocrap-codegen/src/generator.rs

use std::panic;

use super::protocrap;
use crate::names::*;
use crate::tables;
use anyhow::Result;
use proc_macro2::TokenStream;
use protocrap::ProtobufRef;
use protocrap::google::protobuf::DescriptorProto::ProtoType as DescriptorProto;
use protocrap::google::protobuf::EnumDescriptorProto::ProtoType as EnumDescriptorProto;
use protocrap::google::protobuf::FieldDescriptorProto::Type;
use protocrap::google::protobuf::FileDescriptorProto::ProtoType as FileDescriptorProto;
use protocrap::google::protobuf::FileDescriptorSet::ProtoType as FileDescriptorSet;
use protocrap::reflection::is_repeated;
use protocrap::reflection::needs_has_bit;
use quote::{format_ident, quote};

#[allow(dead_code)]
pub(crate) fn generate_file_set(file_set: &FileDescriptorSet) -> Result<TokenStream> {
    // Build a tree of packages to handle hierarchical namespaces properly
    // This avoids duplicate module declarations for packages like:
    //   - protobuf_test_messages.proto2
    //   - protobuf_test_messages.proto3
    // which should both go under a single pub mod protobuf_test_messages { ... }

    #[derive(Default)]
    struct PackageNode {
        file_contents: Vec<TokenStream>,
        children: std::collections::BTreeMap<String, PackageNode>,
    }

    let mut root = PackageNode::default();

    // Organize files into package tree
    for file in file_set.file() {
        let content = generate_file_content(file)?;
        let package = file.package();

        if package.is_empty() {
            // Root package
            root.file_contents.push(content);
        } else {
            // Navigate/create tree nodes
            let parts: Vec<&str> = package.split('.').collect();
            let mut node = &mut root;
            for part in parts {
                node = node.children.entry(part.to_string()).or_default();
            }
            node.file_contents.push(content);
        }
    }

    // Generate code from tree
    fn generate_node(node: &PackageNode) -> TokenStream {
        let mut items = node.file_contents.clone();

        for (name, child_node) in &node.children {
            let child_content = generate_node(child_node);
            let ident = format_ident!("{}", name);
            items.push(quote! {
                pub mod #ident {
                    use super::protocrap;
                    #child_content
                }
            });
        }

        quote! { #(#items)* }
    }

    let contents = generate_node(&root);

    Ok(quote! {
        // Auto-generated by protocrap-codegen
        // DO NOT EDIT

        #contents
    })
}

/// Generate the content of a single file (without package module wrapping)
fn generate_file_content(file: &FileDescriptorProto) -> Result<TokenStream> {
    let mut items = Vec::new();

    // Generate enums
    for enum_type in file.enum_type() {
        items.push(generate_enum(enum_type)?);
    }

    // Generate messages
    for (idx, message) in file.message_type().iter().enumerate() {
        let mut path = Vec::new();
        path.push(idx);
        items.push(generate_message(message, file, path)?);
    }

    // Generate FILE_DESCRIPTOR_PROTO in a dedicated module to avoid name collisions
    // when multiple files share the same package
    let file_descriptor = if file.name() == "proto/descriptor.proto" {
        // Special case: generate FileDescriptorProto static
        let mut pool = protocrap::reflection::DescriptorPool::new(&std::alloc::Global);
        pool.add_file(file);
        let serialized = file.encode_vec::<100>()?;
        let mut arena = protocrap::arena::Arena::new(&std::alloc::Global);
        let dyn_file_descriptor = pool.decode_message(
            "google.protobuf.FileDescriptorProto",
            &serialized,
            &mut arena,
        )?;
        crate::static_gen::generate_static_dynamic(&dyn_file_descriptor)?
    } else {
        let dynamic_file = protocrap::reflection::DynamicMessageRef::new(file);
        crate::static_gen::generate_static_dynamic(&dynamic_file)?
    };

    // Create a unique module name based on the proto filename (without path and extension)
    let filename = std::path::Path::new(file.name())
        .file_stem()
        .and_then(|s| s.to_str())
        .unwrap_or("file");
    let mod_name = format_ident!("_{}", sanitize_module_name(filename));

    items.push(quote! {
        #[doc(hidden)]
        pub mod #mod_name {
            use super::protocrap;
            pub static FILE_DESCRIPTOR_PROTO: protocrap::google::protobuf::FileDescriptorProto::ProtoType = #file_descriptor;
        }
    });

    Ok(quote! { #(#items)* })
}

fn generate_enum(enum_desc: &&EnumDescriptorProto) -> Result<TokenStream> {
    let name = format_ident!("{}", enum_desc.name());

    // Deduplicate enum values - Rust doesn't support aliased enum variants
    // Keep only the first variant for each numeric value
    let mut seen_values = std::collections::HashSet::new();
    let unique_values: Vec<_> = enum_desc
        .value()
        .iter()
        .filter(|v| seen_values.insert(v.number()))
        .collect();

    // Enum variants
    let variants: Vec<_> = unique_values
        .iter()
        .map(|v| {
            let variant_name = format_ident!("{}", v.name());
            let number = v.number();
            quote! { #variant_name = #number }
        })
        .collect();

    // from_i32 match arms - use the deduplicated values
    let from_i32_arms: Vec<_> = unique_values
        .iter()
        .map(|v| {
            let variant_name = format_ident!("{}", v.name());
            let number = v.number();
            quote! { #number => Some(Self::#variant_name) }
        })
        .collect();

    Ok(quote! {
        #[repr(i32)]
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        #[allow(non_camel_case_types)]
        pub enum #name {
            #(#variants,)*
        }

        impl #name {
            pub const fn from_i32(value: i32) -> Option<Self> {
                match value {
                    #(#from_i32_arms,)*
                    _ => None,
                }
            }

            pub const fn to_i32(self) -> i32 {
                self as i32
            }
        }
    })
}

fn generate_message(
    message: &DescriptorProto,
    file: &FileDescriptorProto,
    path: Vec<usize>,
) -> Result<TokenStream> {
    let msg = generate_message_impl(message, file, path)?;
    let name = format_ident!("{}", sanitize_field_name(message.name()));

    Ok(quote! {
        #[allow(non_snake_case)]
        pub mod #name {
            use super::protocrap;
            #[allow(unused_imports)]
            use protocrap::Protobuf;
            #msg
        }
    })
}

fn generate_message_impl(
    message: &DescriptorProto,
    file: &FileDescriptorProto,
    path: Vec<usize>,
) -> Result<TokenStream> {
    // Nested types first

    let mut nested_items = Vec::new();
    for (idx, nested) in message.nested_type().iter().enumerate() {
        let mut nested_path = path.clone();
        nested_path.push(idx);
        nested_items.push(generate_message(nested, file, nested_path)?);
    }

    let nested_enums: Vec<_> = message
        .enum_type()
        .iter()
        .map(generate_enum)
        .collect::<Result<Vec<_>, _>>()?;

    // Calculate has bits
    let has_bit_fields: Vec<_> = message
        .field()
        .iter()
        .filter(|f| needs_has_bit(f))
        .collect();

    let has_bits_count = has_bit_fields.len();
    let has_bits_words = has_bits_count.div_ceil(32);

    // Struct fields
    let struct_fields: Vec<_> = message
        .field()
        .iter()
        .map(|&field| {
            let field_name = format_ident!("{}", sanitize_field_name(field.name()));
            let field_type = rust_field_type_tokens(field);
            (
                field_name.clone(),
                (field.number(), quote! { #field_name: #field_type }),
            )
        })
        .collect();

    let (struct_field_names, struct_fields): (Vec<_>, Vec<_>) = struct_fields.into_iter().unzip();
    let mut sorted_struct_fields: Vec<_> = struct_fields.clone();
    sorted_struct_fields.sort_by_key(|(field_num, _)| *field_num);

    let (_, struct_fields): (Vec<_>, Vec<_>) = struct_fields.into_iter().unzip();
    let (_, sorted_struct_fields): (Vec<_>, Vec<_>) = sorted_struct_fields.into_iter().unzip();

    // Build has_bit map
    let has_bit_map: std::collections::HashMap<_, _> = has_bit_fields
        .iter()
        .enumerate()
        .map(|(i, f)| (f.number(), i))
        .collect();

    // Accessor methods
    let accessors = generate_accessors(message, &has_bit_map)?;

    // Protobuf trait impl
    let protobuf_impl = generate_protobuf_impl();

    let table = tables::generate_table(message, &has_bit_map, Some(file.syntax()))?;

    // Build path to FILE_DESCRIPTOR_PROTO in the file-specific module
    let filename = std::path::Path::new(file.name())
        .file_stem()
        .and_then(|s| s.to_str())
        .unwrap_or("file");
    let file_mod_name = format_ident!("_{}", sanitize_module_name(filename));
    let file_descriptor_ident = format_ident!("FILE_DESCRIPTOR_PROTO");

    let package = file.package();
    let file_descriptor_path = if package.is_empty() {
        quote! { crate::#file_mod_name::#file_descriptor_ident }
    } else {
        let mut parts: Vec<_> = package.split('.').map(|s| format_ident!("{}", s)).collect();
        parts.push(file_mod_name);
        parts.push(file_descriptor_ident);

        quote! { crate::#(#parts)::* }
    };

    let message_descriptor_accessor = build_descriptor_accessor(&path);

    Ok(quote! {
        #(#nested_items)*
        #(#nested_enums)*

        #[repr(C)]
        #[derive(Default)]
        pub struct ProtoType {
            has_bits: [u32; #has_bits_words],
            #(#struct_fields,)*
        }

        impl core::fmt::Debug for ProtoType {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                protocrap::reflection::debug_message(self, f)
            }
        }

        impl ProtoType {
            #[allow(clippy::too_many_arguments)]
            pub const fn from_static(
                has_bits: [u32; #has_bits_words],
                #(#sorted_struct_fields,)*
            ) -> Self {
                Self {
                    has_bits,
                    #(#struct_field_names,)*
                }
            }

            pub fn clear(&mut self) {
                *self = unsafe { core::mem::zeroed() };
            }

            pub const fn file_descriptor() -> &'static protocrap::google::protobuf::FileDescriptorProto::ProtoType {
                &#file_descriptor_path
            }

            const fn descriptor_proto() -> &'static protocrap::google::protobuf::DescriptorProto::ProtoType {
                #message_descriptor_accessor
            }

            #accessors
        }

        #protobuf_impl
        #table
    })
}

fn unescape_proto_string(s: &str) -> Result<Vec<u8>> {
    let mut result = Vec::new();
    let mut chars = s.chars();

    while let Some(ch) = chars.next() {
        if ch == '\\' {
            match chars.next() {
                Some('n') => result.push('\n' as u8),
                Some('t') => result.push('\t' as u8),
                Some('r') => result.push('\r' as u8),
                Some('\\') => result.push('\\' as u8),
                Some('"') => result.push('"' as u8),
                Some('\'') => result.push('\'' as u8),
                Some('x') => {
                    // \xHH - hex byte
                    let hex: String = chars.by_ref().take(2).collect();
                    if let Ok(byte) = u8::from_str_radix(&hex, 16) {
                        result.push(byte);
                    } else {
                        anyhow::bail!("Invalid hex escape: \\x{}", hex);
                    }
                }
                Some(c) if c.is_ascii_digit() => {
                    // \ooo - octal byte (up to 3 digits)
                    let mut octal = String::from(c);
                    for _ in 0..2 {
                        if let Some(next) = chars.clone().next() {
                            if next.is_ascii_digit() && next < '8' {
                                octal.push(next);
                                chars.next();
                            } else {
                                break;
                            }
                        }
                    }
                    if let Ok(byte) = u8::from_str_radix(&octal, 8) {
                        result.push(byte);
                    } else {
                        anyhow::bail!("Invalid octal escape: \\{}", octal);
                    }
                }
                Some(c) => {
                    anyhow::bail!("Unknown escape sequence: \\{}", c);
                }
                None => {
                    anyhow::bail!("Incomplete escape sequence at end of string");
                }
            }
        } else {
            result.push(ch as u8);
        }
    }

    Ok(result)
}

fn parse_primitive_default(
    field: &protocrap::google::protobuf::FieldDescriptorProto::ProtoType,
) -> Option<TokenStream> {
    let Some(default_str) = field.get_default_value() else {
        return None;
    };
    match field.r#type()? {
        Type::TYPE_INT32 | Type::TYPE_SINT32 | Type::TYPE_SFIXED32 => {
            let value = default_str.parse::<i32>().unwrap();
            if value != 0 {
                Some(quote! { #value })
            } else {
                None
            }
        }
        Type::TYPE_INT64 | Type::TYPE_SINT64 | Type::TYPE_SFIXED64 => {
            let value = default_str.parse::<i64>().unwrap();
            if value != 0 {
                Some(quote! { #value })
            } else {
                None
            }
        }
        Type::TYPE_UINT32 | Type::TYPE_FIXED32 => {
            let value = default_str.parse::<u32>().unwrap();
            if value != 0 {
                Some(quote! { #value })
            } else {
                None
            }
        }
        Type::TYPE_UINT64 | Type::TYPE_FIXED64 => {
            let value = default_str.parse::<u64>().unwrap();
            if value != 0 {
                Some(quote! { #value })
            } else {
                None
            }
        }
        Type::TYPE_BOOL => match default_str {
            "true" => Some(quote! { true }),
            "false" => Some(quote! { false }),
            _ => panic!("Invalid boolean default value: {}", default_str),
        },
        Type::TYPE_FLOAT => {
            // Handle special float values
            match default_str {
                "inf" => Some(quote! { f32::INFINITY }),
                "-inf" => Some(quote! { f32::NEG_INFINITY }),
                "nan" => Some(quote! { f32::NAN }),
                _ => {
                    let value = default_str.parse::<f32>().unwrap();
                    if value != 0.0 {
                        Some(quote! { #value })
                    } else {
                        None
                    }
                }
            }
        }
        Type::TYPE_DOUBLE => {
            // Handle special double values
            match default_str {
                "inf" => Some(quote! { f64::INFINITY }),
                "-inf" => Some(quote! { f64::NEG_INFINITY }),
                "nan" => Some(quote! { f64::NAN }),
                _ => {
                    let value = default_str.parse::<f64>().unwrap();
                    if value != 0.0 {
                        Some(quote! { #value })
                    } else {
                        None
                    }
                }
            }
        }
        Type::TYPE_STRING => {
            if default_str.is_empty() {
                return None;
            } else {
                Some(quote! { #default_str })
            }
        }
        Type::TYPE_BYTES => match unescape_proto_string(default_str) {
            Ok(unescaped) => {
                if unescaped.is_empty() {
                    None
                } else {
                    Some(quote! { &[#(#unescaped),*] })
                }
            }
            Err(_) => panic!("Invalid bytes default value: {}", default_str),
        },
        Type::TYPE_ENUM => {
            // TODO: Handle enum default values
            None
        }
        Type::TYPE_MESSAGE | Type::TYPE_GROUP => {
            unreachable!("Messages cannot have default values")
        }
    }
}

fn generate_accessors(
    message: &DescriptorProto,
    has_bit_map: &std::collections::HashMap<i32, usize>,
) -> Result<TokenStream> {
    let mut methods = Vec::new();

    for &field in message.field() {
        let field_name = format_ident!("{}", sanitize_field_name(field.name()));

        if is_repeated(field) {
            // Repeated field accessor
            if field.r#type() == Some(Type::TYPE_MESSAGE)
                || field.r#type() == Some(Type::TYPE_GROUP)
            {
                // Repeated message field
                let msg_type = rust_type_tokens(field);
                let field_name_mut = format_ident!("{}_mut", field_name);
                let add_field_name = format_ident!("add_{}", field_name);
                methods.push(quote! {
                    pub const fn #field_name(&self) -> &[&#msg_type::ProtoType] {
                        unsafe { core::mem::transmute(self.#field_name.slice()) }
                    }

                    pub fn #field_name_mut(&mut self) -> &mut protocrap::containers::RepeatedField<&mut #msg_type::ProtoType> {
                        unsafe { core::mem::transmute(&mut self.#field_name) }
                    }

                    pub fn #add_field_name(&mut self, arena: &mut protocrap::arena::Arena) -> &mut #msg_type::ProtoType {
                        let elem = arena.alloc::<#msg_type::ProtoType>();
                        let msg = protocrap::base::Message(elem as *mut protocrap::base::Object);
                        let value = unsafe { 
                            elem.write(#msg_type::ProtoType::default());
                            &mut *elem
                        };
                        self.#field_name.push(msg, arena);
                        value
                    }
                });
                continue;
            }
            let element_type = rust_element_type_tokens(field);
            let field_name_mut = format_ident!("{}_mut", field_name);
            methods.push(quote! {
                pub const fn #field_name(&self) -> &[#element_type] {
                    self.#field_name.slice()
                }

                pub fn #field_name_mut(&mut self) -> &mut protocrap::containers::RepeatedField<#element_type> {
                    &mut self.#field_name
                }
            });
        } else {
            let setter_name = format_ident!("set_{}", field_name);
            let optional_setter_name = format_ident!("set_optional_{}", field_name);
            let optional_name = format_ident!("get_{}", field_name);
            let clear_name = format_ident!("clear_{}", field_name);
            let has_name = format_ident!("has_{}", field_name);
            let has_bit = if let Some(has_bit) = has_bit_map.get(&field.number()).cloned() {
                methods.push(quote! {
                    pub const fn #has_name(&self) -> bool {
                        unsafe { (*(self as *const _ as *const protocrap::base::Object)).has_bit(#has_bit as u8) }
                    }
                });
                has_bit as u32
            } else {
                0
            };
            match field.r#type().unwrap() {
                Type::TYPE_STRING => {
                    // Parse default value if present
                    let default_value = parse_primitive_default(field);

                    let getter_impl =
                        if has_bit_map.contains_key(&field.number()) && default_value.is_some() {
                            let default_tokens = default_value.unwrap();
                            quote! {
                                if self.#has_name() {
                                    self.#field_name.as_str()
                                } else {
                                    #default_tokens
                                }
                            }
                        } else {
                            quote! { self.#field_name.as_str() }
                        };

                    methods.push(quote! {
                        pub const fn #field_name(&self) -> &str {
                            #getter_impl
                        }

                        pub const fn #optional_name(&self) -> Option<&str> {
                            if self.#has_name() {
                                Some(self.#field_name.as_str())
                            } else {
                                None
                            }
                        }

                        pub fn #setter_name(&mut self, value: &str, arena: &mut protocrap::arena::Arena) {
                            self.as_object_mut().set_has_bit(#has_bit);
                            self.#field_name.assign(value, arena);
                        }

                        pub fn #optional_setter_name(&mut self, value: Option<&str>, arena: &mut protocrap::arena::Arena) {
                            match value {
                                Some(v) => self.#setter_name(v, arena),
                                None => self.#clear_name(),
                            }
                        }

                        pub fn #clear_name(&mut self) {
                            self.as_object_mut().clear_has_bit(#has_bit);
                            self.#field_name.clear();
                        }
                    });
                }
                Type::TYPE_BYTES => {
                    let default_value = parse_primitive_default(field);
                    let getter_impl = if let Some(default_tokens) = default_value {
                        quote! {
                            if self.#has_name() {
                                self.#field_name.slice()
                            } else {
                                #default_tokens
                            }
                        }
                    } else {
                        quote! { self.#field_name.slice() }
                    };
                    methods.push(quote! {
                        pub const fn #field_name(&self) -> &[u8] {
                            #getter_impl
                        }

                        pub const fn #optional_name(&self) -> Option<&[u8]> {
                            if self.#has_name() {
                                Some(self.#field_name.slice())
                            } else {
                                None
                            }
                        }

                        pub fn #setter_name(&mut self, value: &[u8], arena: &mut protocrap::arena::Arena) {
                            self.as_object_mut().set_has_bit(#has_bit);
                            self.#field_name.assign(value, arena);
                        }

                        pub fn #optional_setter_name(&mut self, value: Option<&[u8]>, arena: &mut protocrap::arena::Arena) {
                            match value {
                                Some(v) => self.#setter_name(v, arena),
                                None => self.#clear_name(),
                            }
                        }

                        pub fn #clear_name(&mut self) {
                            self.as_object_mut().clear_has_bit(#has_bit);
                            self.#field_name.clear();
                        }
                    });
                }
                Type::TYPE_MESSAGE | Type::TYPE_GROUP => {
                    let msg_type = rust_type_tokens(field);
                    let field_name_mut = format_ident!("{}_mut", field_name);
                    methods.push(quote! {
                        pub const fn #has_name(&self) -> bool {
                            !self.#field_name.0.is_null()
                        }
                        
                        pub const fn #field_name(&self) -> Option<&#msg_type::ProtoType> {
                            if self.#has_name() {
                                Some(unsafe { &*(self.#field_name.0 as *const #msg_type::ProtoType) })
                            } else {
                                None
                            }
                        }

                        pub fn #field_name_mut(&mut self, arena: &mut protocrap::arena::Arena) -> &mut #msg_type::ProtoType {
                            let object = self.#field_name;
                            if object.0.is_null() {
                                let new_object = protocrap::base::Object::create(
                                    core::mem::size_of::<#msg_type::ProtoType>() as u32,
                                    arena
                                );
                                self.#field_name = protocrap::base::Message(new_object);
                            }
                            unsafe { &mut *(self.#field_name.0 as *mut #msg_type::ProtoType) }
                        }

                        pub fn #clear_name(&mut self) {
                            self.#field_name = protocrap::base::Message(core::ptr::null_mut());
                        }
                    });
                }
                Type::TYPE_ENUM => {
                    let enum_type = rust_type_tokens(field);
                    methods.push(quote! {
                        pub const fn #field_name(&self) -> Option<#enum_type> {
                            #enum_type::from_i32(self.#field_name)
                        }

                        pub fn #setter_name(&mut self, value: #enum_type) {
                            self.as_object_mut().set_has_bit(#has_bit);
                            self.#field_name = value.to_i32();
                        }

                        pub fn #optional_setter_name(&mut self, value: Option<#enum_type>) {
                            match value {
                                Some(v) => self.#setter_name(v),
                                None => self.#clear_name(),
                            }
                        }

                        pub fn #clear_name(&mut self) {
                            self.as_object_mut().clear_has_bit(#has_bit);
                            self.#field_name = 0;
                        }
                    });
                }
                _ => {
                    // Scalar types
                    let return_type = rust_element_type_tokens(field);

                    // Parse default value if present
                    let default_value = parse_primitive_default(field);

                    let getter_impl = if default_value.is_some() {
                        let default_tokens = default_value.unwrap();
                        quote! {
                            if self.#has_name() {
                                self.#field_name
                            } else {
                                #default_tokens
                            }
                        }
                    } else {
                        quote! { self.#field_name }
                    };

                    methods.push(quote! {
                        pub const fn #field_name(&self) -> #return_type {
                            #getter_impl
                        }

                        pub const fn #optional_name(&self) -> Option<#return_type> {
                            if self.#has_name() {
                                Some(self.#field_name)
                            } else {
                                None
                            }
                        }

                        pub fn #setter_name(&mut self, value: #return_type) {
                            self.as_object_mut().set_has_bit(#has_bit);
                            self.#field_name = value;
                        }

                        pub fn #optional_setter_name(&mut self, value: Option<#return_type>) {
                            match value {
                                Some(v) => self.#setter_name(v),
                                None => self.#clear_name(),
                            }
                        }

                        pub fn #clear_name(&mut self) {
                            self.as_object_mut().clear_has_bit(#has_bit);
                            self.#field_name = Default::default();
                        }
                    });
                }
            }
        }
    }

    Ok(quote! { #(#methods)* })
}

fn build_descriptor_accessor(path: &[usize]) -> TokenStream {
    if path.is_empty() {
        panic!("Message path cannot be empty");
    }

    let mut accessor = quote! { Self::file_descriptor() };

    for (level, &index) in path.iter().enumerate() {
        let index_lit = proc_macro2::Literal::usize_unsuffixed(index);

        if level == 0 {
            // First level: file's message_type array
            accessor = quote! {
                #accessor.message_type()[#index_lit]
            };
        } else {
            // Nested levels: nested_type array
            accessor = quote! {
                #accessor.nested_type()[#index_lit]
            };
        }
    }

    accessor
}

fn generate_protobuf_impl() -> TokenStream {
    quote! {
        impl protocrap::Protobuf for ProtoType {
            fn table() -> &'static protocrap::tables::Table {
                &TABLE.table
            }
        }
    }
}
